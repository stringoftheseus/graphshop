TODO LIST:


Graph Representation Prototype:


DONE 1. Create Tournament, the prototype Representation. This will be very tiny
and only have one public function that tells you which way a particular arc
is pointing; well, maybe that and another function that returns the score
sequence actually would be useful.

DONE 2. Create the TournamentPanel, which displays the tournament in "all arcs not
shown assumed to be pointing down" mode, as is sometimes common for tournys.

	DONE 2.1. Start by copying everything from DrawWindow, just to make sure that it
	all works. Add it to the GraphPacks so we can turn them on to test.

	DONE 2.2. Throw away everything we don't need for Tournament view, such as the
	edgedraw class, and a bunch of the toolbar items with their associated code.

	DONE 2.3. Create a new Tournament object for the Window based on the given source,
	and hook up all the signals to that instead of the main Graph.

	DONE 2.4. Store a position int in each of the tournamentvertexdraw items. Update
	those for all the vertices to be sequencial in number. Have the vertex always
	move itself to be in a position at (20*n, 0) or so, where n is its index.

	DONE 2.5. Modify tournamentarcdraw items to print themselves as circular arcs going
	above the vertex row. This should be black if the arc goes from right to left,
	and a real light grey otherwise.

	DONE 2.6. Create onclick handlers for the arcs, the implementation of which will
	flip the associated arc in the source graph.

	DONE 2.7. See about dragging vertices around. The idea here is that the vertical
	position of a vertex cannot change (it's always 0) but the horizontal position
	can change with a drag, and if it passes that of another vertex (in either
	direction) this vertex and that one switch indices. At the end of a drag the
	vertex goes back to its index-based position, but if an index changed then it
	ends up in the new position.

	I can see this taking seven hours to get right, or seven minutes. It all just
	depends on how friendly the APIs are and whether I get it bug-free the first
	time.


3. Do IntervalGraph. This is just like Tournament, only lots more complicated.









Smart Draw Windows:

~. Create protected functions in GraphLink for enabling/disabling the
various graph modification functions. To implement this, we may have to
make all such modification functions in Graph be virtual, and have GraphLink
override each with a little function that checks to see if that is allowed
and passes the call on to Graph:: if so and does nothing (or complains)
herwise.

Alternately, we just do this in Graph itself. The advantage of doing it in
Graph is that this functionality is thus available to scripting. You could,
for example, disable all but certain modification functions from script in
order to make sure you didn't mess with the Graph in a way that you didn't
want to, sort of like const but with multiple levels and options.

If we do it the Graph way (and I'm thinking we should), then we don't even
need GraphDraw derived classes. We can just go straight to:


~. Teach GraphDraw to read and respect the permissions set on the Graph.
Meaning, if a certain function is enabled or disabled there, don't show
the UI controls to perform that action. If this works we won't even need
a GraphLinkDraw subclass, much less ConverseGraphDraw etc subclasses for
every derived graph, because all the important functions will happen
automagically for every graph.


~. Think about how best to synchronize layouts between the main draw and a
linked draw panel (or perhaps any two panel windows) in the ui...



Smart Scripting:

#. Create a ScriptEngine subclass GraphScriptEngine which automatically sets
itself up (see GraphShopApp::setupScripting).

#. As part of the above, create a new global object for the scipting engine,
maybe via a separate class (or just part of GraphScriptEngine). Copy all the
properties of the original global object over to the new one.

#. Create magic properties window and graph, which use getter functions on
the global object to always be equal the currently active window and the
graph selected in the same respectively.
